import {
  SUI_ADDRESS_LENGTH,
  TypeTagSerializer,
  deriveDynamicFieldID,
  normalizeStructTag,
  parseStructTag,
  suiBcs
} from "./chunk-PREL4TK5.js";

// node_modules/.pnpm/@mysten+sui@1.29.1_typescript@5.7.3/node_modules/@mysten/sui/dist/esm/experimental/cache.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _prefix;
var _cache;
var _ClientCache = class _ClientCache2 {
  constructor({ prefix, cache } = {}) {
    __privateAdd(this, _prefix);
    __privateAdd(this, _cache);
    __privateSet(this, _prefix, prefix ?? []);
    __privateSet(this, _cache, cache ?? /* @__PURE__ */ new Map());
  }
  read(key, load) {
    const cacheKey = [__privateGet(this, _prefix), ...key].join(":");
    if (__privateGet(this, _cache).has(cacheKey)) {
      return __privateGet(this, _cache).get(cacheKey);
    }
    const result = load();
    __privateGet(this, _cache).set(cacheKey, result);
    if (typeof result === "object" && result !== null && "then" in result) {
      return Promise.resolve(result).then((v) => {
        __privateGet(this, _cache).set(cacheKey, v);
        return v;
      }).catch((err) => {
        __privateGet(this, _cache).delete(cacheKey);
        throw err;
      });
    }
    return result;
  }
  clear(prefix) {
    const prefixKey = [...__privateGet(this, _prefix), ...prefix ?? []].join(":");
    if (!prefixKey) {
      __privateGet(this, _cache).clear();
      return;
    }
    for (const key of __privateGet(this, _cache).keys()) {
      if (key.startsWith(prefixKey)) {
        __privateGet(this, _cache).delete(key);
      }
    }
  }
  scope(prefix) {
    return new _ClientCache2({
      prefix: [...__privateGet(this, _prefix), ...Array.isArray(prefix) ? prefix : [prefix]],
      cache: __privateGet(this, _cache)
    });
  }
};
_prefix = /* @__PURE__ */ new WeakMap();
_cache = /* @__PURE__ */ new WeakMap();
var ClientCache = _ClientCache;

// node_modules/.pnpm/@mysten+sui@1.29.1_typescript@5.7.3/node_modules/@mysten/sui/dist/esm/experimental/client.js
var Experimental_BaseClient = class {
  constructor({ network }) {
    this.cache = new ClientCache();
    this.network = network;
  }
  $extend(...registrations) {
    return Object.create(
      this,
      Object.fromEntries(
        registrations.map((registration) => {
          if ("experimental_asClientExtension" in registration) {
            const { name, register } = registration.experimental_asClientExtension();
            return [name, { value: register(this) }];
          }
          return [registration.name, { value: registration.register(this) }];
        })
      )
    );
  }
};

// node_modules/.pnpm/@mysten+sui@1.29.1_typescript@5.7.3/node_modules/@mysten/sui/dist/esm/experimental/core.js
var Experimental_CoreClient = class extends Experimental_BaseClient {
  constructor() {
    super(...arguments);
    this.core = this;
  }
  async getObject(options) {
    const { objectId } = options;
    const {
      objects: [result]
    } = await this.getObjects({ objectIds: [objectId], signal: options.signal });
    if (result instanceof Error) {
      throw result;
    }
    return { object: result };
  }
  async getDynamicField(options) {
    const fieldId = deriveDynamicFieldID(
      options.parentId,
      TypeTagSerializer.parseFromStr(options.name.type),
      options.name.bcs
    );
    const {
      objects: [fieldObject]
    } = await this.getObjects({
      objectIds: [fieldId],
      signal: options.signal
    });
    if (fieldObject instanceof Error) {
      throw fieldObject;
    }
    const fieldType = parseStructTag(fieldObject.type);
    return {
      dynamicField: {
        id: fieldObject.id,
        digest: fieldObject.digest,
        version: fieldObject.version,
        type: fieldObject.type,
        name: {
          type: typeof fieldType.typeParams[0] === "string" ? fieldType.typeParams[0] : normalizeStructTag(fieldType.typeParams[0]),
          bcs: options.name.bcs
        },
        value: {
          type: typeof fieldType.typeParams[1] === "string" ? fieldType.typeParams[1] : normalizeStructTag(fieldType.typeParams[1]),
          bcs: fieldObject.content.slice(SUI_ADDRESS_LENGTH + options.name.bcs.length)
        }
      }
    };
  }
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    ...input
  }) {
    const abortSignal = signal ? AbortSignal.any([AbortSignal.timeout(timeout), signal]) : AbortSignal.timeout(timeout);
    const abortPromise = new Promise((_, reject) => {
      abortSignal.addEventListener("abort", () => reject(abortSignal.reason));
    });
    abortPromise.catch(() => {
    });
    while (true) {
      abortSignal.throwIfAborted();
      try {
        return await this.getTransaction({
          ...input,
          signal: abortSignal
        });
      } catch (e) {
        await Promise.race([new Promise((resolve) => setTimeout(resolve, 2e3)), abortPromise]);
      }
    }
  }
};

// node_modules/.pnpm/@mysten+sui@1.29.1_typescript@5.7.3/node_modules/@mysten/sui/dist/esm/experimental/errors.js
var SuiClientError = class extends Error {
};
var ObjectError = class _ObjectError extends SuiClientError {
  constructor(code, message) {
    super(message);
    this.code = code;
  }
  static fromResponse(response, objectId) {
    switch (response.code) {
      case "notExists":
        return new _ObjectError(response.code, `Object ${response.object_id} does not exist`);
      case "dynamicFieldNotFound":
        return new _ObjectError(
          response.code,
          `Dynamic field not found for object ${response.parent_object_id}`
        );
      case "deleted":
        return new _ObjectError(response.code, `Object ${response.object_id} has been deleted`);
      case "displayError":
        return new _ObjectError(response.code, `Display error: ${response.error}`);
      case "unknown":
      default:
        return new _ObjectError(
          response.code,
          `Unknown error while loading object${objectId ? ` ${objectId}` : ""}`
        );
    }
  }
};

// node_modules/.pnpm/@mysten+sui@1.29.1_typescript@5.7.3/node_modules/@mysten/sui/dist/esm/experimental/transports/utils.js
function parseTransactionEffects({
  effects,
  epoch,
  objectTypes
}) {
  const parsed = suiBcs.TransactionEffects.parse(effects);
  switch (parsed.$kind) {
    case "V1":
      return parseTransactionEffectsV1({ bytes: effects, effects: parsed.V1, epoch, objectTypes });
    case "V2":
      return parseTransactionEffectsV2({ bytes: effects, effects: parsed.V2, epoch, objectTypes });
    default:
      throw new Error(
        `Unknown transaction effects version: ${parsed.$kind}`
      );
  }
}
function parseTransactionEffectsV1(_) {
  throw new Error("V1 effects are not supported yet");
}
function parseTransactionEffectsV2({
  bytes,
  effects,
  epoch,
  objectTypes
}) {
  const changedObjects = effects.changedObjects.map(
    ([id, change]) => {
      var _a, _b, _c, _d, _e, _f;
      return {
        id,
        inputState: change.inputState.$kind === "Exist" ? "Exists" : "DoesNotExist",
        inputVersion: ((_a = change.inputState.Exist) == null ? void 0 : _a[0][0]) ?? null,
        inputDigest: ((_b = change.inputState.Exist) == null ? void 0 : _b[0][1]) ?? null,
        inputOwner: ((_c = change.inputState.Exist) == null ? void 0 : _c[1]) ?? null,
        outputState: change.outputState.$kind === "NotExist" ? "DoesNotExist" : change.outputState.$kind,
        outputVersion: change.outputState.$kind === "PackageWrite" ? (_d = change.outputState.PackageWrite) == null ? void 0 : _d[0] : change.outputState.ObjectWrite ? effects.lamportVersion : null,
        outputDigest: change.outputState.$kind === "PackageWrite" ? (_e = change.outputState.PackageWrite) == null ? void 0 : _e[1] : ((_f = change.outputState.ObjectWrite) == null ? void 0 : _f[0]) ?? null,
        outputOwner: change.outputState.ObjectWrite ? change.outputState.ObjectWrite[1] : null,
        idOperation: change.idOperation.$kind,
        objectType: objectTypes[id] ?? null
      };
    }
  );
  return {
    bcs: bytes,
    digest: effects.transactionDigest,
    version: 2,
    status: effects.status.$kind === "Success" ? {
      success: true,
      error: null
    } : {
      success: false,
      // TODO: add command
      error: effects.status.Failed.error.$kind
    },
    epoch: epoch ?? null,
    gasUsed: effects.gasUsed,
    transactionDigest: effects.transactionDigest,
    gasObject: effects.gasObjectIndex === null ? null : changedObjects[effects.gasObjectIndex] ?? null,
    eventsDigest: effects.eventsDigest,
    dependencies: effects.dependencies,
    lamportVersion: effects.lamportVersion,
    changedObjects,
    unchangedSharedObjects: effects.unchangedSharedObjects.map(
      ([objectId, object]) => {
        return {
          kind: object.$kind,
          objectId,
          version: object.$kind === "ReadOnlyRoot" ? object.ReadOnlyRoot[0] : object[object.$kind],
          digest: object.$kind === "ReadOnlyRoot" ? object.ReadOnlyRoot[1] : null,
          objectType: objectTypes[objectId] ?? null
        };
      }
    ),
    auxiliaryDataDigest: effects.auxDataDigest
  };
}

export {
  Experimental_BaseClient,
  Experimental_CoreClient,
  ObjectError,
  parseTransactionEffects
};
//# sourceMappingURL=chunk-NQQ3B7XW.js.map
